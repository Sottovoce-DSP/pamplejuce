#  ___                 _        _                ___ ___ 
# | _ \__ _ _ __  _ __| |___ _ | |_  _ __ ___   / __|_ _|
# |  _/ _` | '  \| '_ \ / -_) || | || / _/ -_) | (__ | | 
# |_| \__,_|_|_|_| .__/_\___|\__/ \_,_\__\___|  \___|___|
#                |_|                                     

name: YAML Build and Test

# Recent Change List
# - Strip binary symbols after testing, before codesign (November 1 2024)

# [===================================================================]
# [================ Global Variables Needed By Runner ================]
# [===================================================================]

# For Google Drive upload
permissions:
  id-token: write
  contents: read

on:
  workflow_dispatch: # lets you run a build from the UI
  #push:
  #pull_request:

# When pushing new commits, cancel any running builds on that branch
concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

env:
  BUILD_TYPE: Release
  BUILD_DIR: Builds
  DISPLAY: :0 # linux pluginval needs this
  HOMEBREW_NO_INSTALL_CLEANUP: 1
  SCCACHE_GHA_ENABLED: true
  SCCACHE_CACHE_MULTIARCH: 1
  IPP_DIR: C:\Program Files (x86)\Intel\oneAPI\ipp\latest\lib\cmake\ipp
  SHOULD_STRIP_SYMBOLS: false
  TEST_SYMBOL: processBlock

defaults:
  run:
    shell: bash

# [======================================]
# [================ Jobs ================]
# [======================================]

# jobs are run in paralell on different machines
# all steps run in series
jobs:
  build_and_test:
    # don't double run on PRs
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name != github.event.pull_request.base.repo.full_name
    name: ${{ matrix.name }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false # show all errors for each platform (vs. cancel jobs on error)
      matrix:
        include:
          # - name: Linux
          #   os: ubuntu-22.04
          #   pluginval-binary: ./pluginval
          - name: macOS
            os: macos-14
            pluginval-binary: pluginval.app/Contents/MacOS/pluginval
            extra-flags: -DCMAKE_OSX_ARCHITECTURES="arm64;x86_64"
            lameFilename: lame
          # - name: Windows
          #   os: windows-latest
          #   pluginval-binary: ./pluginval.exe
          #   lameFilename: lame.exe

    steps:

      # [====================================================]
      # [================ Setup Environments ================]
      # [====================================================]

      # Figure out how many cores we have to work with
      - name: Set number of cores
        run: |
          echo "Determining number of cores..."
          if [[ "$RUNNER_OS" == "Linux" ]]; then
            CORES=$(nproc)
          elif [[ "$RUNNER_OS" == "macOS" ]]; then
            CORES=$(sysctl -n hw.ncpu)
          elif [[ "$RUNNER_OS" == "Windows" ]]; then
            CORES=$NUMBER_OF_PROCESSORS
          else
            echo "Unknown OS. Defaulting to 2 cores."
            CORES=2
          fi
          echo "NUMBER_OF_CORES=$CORES" >> $GITHUB_ENV
          echo "Detected $CORES cores"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: true # Get JUCE populated

      - name: Save main repo commit to file (macOS)
        if: ${{ matrix.name == 'macOS' }}
        run: git rev-parse HEAD > main_repo_commit.txt

      - name: Save git submodule output to file
        run: |
          git submodule > git_submodule_versions.txt

      - name: Upload submodule output artifact (macOS)
        if: ${{ matrix.name == 'macOS' }}
        uses: actions/upload-artifact@v4
        with:
          name: git_submodule_versions.txt
          path: git_submodule_versions.txt

      - name: Upload main module output artifact (macOS)
        if: ${{ matrix.name == 'macOS' }}
        uses: actions/upload-artifact@v4
        with:
          name: main_repo_commit.txt
          path: main_repo_commit.txt

      # [========================================================]
      # [================ Upload To Google Drive ================]
      # [========================================================]

      # Authenticate and Configure Google Cloud via OIDC
      - name: Authenticate and Configure Google Cloud
        uses: google-github-actions/auth@v1
        with:
          workload_identity_provider: ${{ secrets.GOOGLE_DRIVE_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GOOGLE_DRIVE_SERVICE_ACCOUNT }}
      
      - name: Set GOOGLE_APPLICATION_CREDENTIALS environment variable
        run: echo "GOOGLE_APPLICATION_CREDENTIALS=${{ runner.temp }}/gha-creds.json" >> $GITHUB_ENV

      - name: Install Python Dependencies for Drive Upload
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install google-api-python-client google-auth-httplib2 google-auth-oauthlib

      # Create a Python script inline to handle folder creation & file upload
      - name: Create Python Upload Script
        run: |
          cat > upload_to_drive.py <<EOF
          import os
          import sys
          from google.oauth2 import service_account
          from googleapiclient.discovery import build
          from googleapiclient.http import MediaFileUpload

          SCOPES = ['https://www.googleapis.com/auth/drive.file']
          creds_path = os.getenv('GOOGLE_APPLICATION_CREDENTIALS')
          if not creds_path or not os.path.exists(creds_path):
              print("Error: Credentials file not found at", creds_path)
              sys.exit(1)

          creds = service_account.Credentials.from_service_account_file(
              creds_path, scopes=SCOPES)
          service = build('drive', 'v3', credentials=creds)

          def find_or_create_folder(name, parent_id=None):
              # Search for folder
              query = f"name='{name}' and mimeType='application/vnd.google-apps.folder' and trashed=false"
              if parent_id:
                  query += f" and '{parent_id}' in parents"
              results = service.files().list(q=query, spaces='drive', fields='files(id, name)').execute()
              files = results.get('files', [])
              if files:
                  return files[0]['id']
              # Create if not found
              file_metadata = {
                  'name': name,
                  'mimeType': 'application/vnd.google-apps.folder'
              }
              if parent_id:
                  file_metadata['parents'] = [parent_id]
              folder = service.files().create(body=file_metadata, fields='id').execute()
              return folder.get('id')

          ROOT_FOLDER_NAME = "Release"
          PRODUCT_NAME = os.getenv('PRODUCT_NAME')
          VERSION = os.getenv('VERSION')

          if not PRODUCT_NAME or not VERSION:
              print("PRODUCT_NAME or VERSION is not set.")
              sys.exit(1)

          root_folder_id = find_or_create_folder(ROOT_FOLDER_NAME)
          plugin_folder_id = find_or_create_folder(PRODUCT_NAME, parent_id=root_folder_id)

          import datetime
          now_str = datetime.datetime.utcnow().strftime("%Y-%m-%d_%H-%M")
          version_folder_name = f"Release_{VERSION}_{now_str}"
          version_folder_id = find_or_create_folder(version_folder_name, parent_id=plugin_folder_id)

          # Upload artifacts
          # Pass file paths as arguments to script
          for artifact_path in sys.argv[1:]:
              if not os.path.exists(artifact_path):
                  print(f"Warning: {artifact_path} does not exist. Skipping.")
                  continue
              file_name = os.path.basename(artifact_path)
              media = MediaFileUpload(artifact_path, resumable=True)
              body = {'name': file_name, 'parents': [version_folder_id]}
              uploaded_file = service.files().create(body=body, media_body=media, fields='id').execute()
              print(f"Uploaded {artifact_path} to folder {version_folder_id} (ID: {uploaded_file['id']})")

          # If you want to expose the folder ID for further steps:
          print(f"::set-output name=VERSION_FOLDER_ID::{version_folder_id}")
          EOF

      # Upload macOS-specific artifacts to Google Drive via Python Script
      - name: Upload macOS Artifacts to Google Drive
        if: ${{ matrix.name == 'macOS' }}
        run: |
          echo "Uploading macOS artifacts to Google Drive..."
          DMG_PATH="packaging/${{ env.ARTIFACT_NAME }}.dmg"
          SUBMODULE_PATH="git_submodule_versions.txt"
          COMMIT_PATH="main_repo_commit.txt"
          python3 upload_to_drive.py "$DMG_PATH" "$SUBMODULE_PATH" "$COMMIT_PATH"

  # [=========================================]
  # [================ Release ================]
  # [=========================================]

  release:
    if: contains(github.ref, 'tags/v')
    runs-on: ubuntu-latest
    needs: build_and_test

    steps:
      - name: Get Artifacts
        uses: actions/download-artifact@v4

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          prerelease: true
          files: |
            *.exe
            *.dmg
            git_submodule_versions.txt
            main_repo_commit.txt